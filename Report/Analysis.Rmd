---
title: "Analysis"
author: "Nina"
date: "05/05/2022"
output: html_document
---

```{r, echo = FALSE, message = FALSE}
source(here::here("Scripts/SetUp.R"))
```
## Splitting the data into Traning set and Test set 

```{r}
set.seed(123) ## for replication purpose
## the index of the rows that will be in the training set
index.tr <- sample(1:nrow(bands3_reduced), replace=FALSE,
                   size=0.75*nrow(bands3_reduced))
bands3_reduced.tr <- bands3_reduced[index.tr,] ## the training set
bands3_reduced.te <- bands3_reduced[-index.tr,] ## the test set
```

## Balancing the Training set : PAS BESOIN POUR L'INSTANT

```{r}
#band1 <- min(table(bands3_reduced.tr$band_type)) ## 171
## the "band" cases
#data.tr.band1 <- filter(bands3_reduced.tr, band_type=="band")
## the "noband" cases
#data.tr.band2 <- filter(bands3_reduced.tr, band_type=="noband")

## sub-sample 171 instances from the number of "noband" cases
#index.band2 <- sample(size=band1, 
#                           x=1:nrow(data.tr.band2), 
#                           replace=FALSE)

  
## Bind all the "Central Andes" and the sub-sampled "Central Pyrenees" 
## and the sub-sampled "Sierra de Guadarrama"
#bands3_reduced.tr <- data.frame(rbind(data.tr.band1,
#                                     data.tr.band2[index.band2,])) 
## The cases are now balanced
#table(bands3_reduced.tr$band_type)
```

### Replace the NAs by the mean of the closest observations
Some of the models we use do not work with NAs. To deal with them, we decided to replace the 2 NAs we have by the mean of their closest observations. 

```{r}
mean_for_fill <-colMeans( Mountain_data_cleaned %>%
  select(Plot,Glu_P)%>%
  filter(Plot %in% c(76, 77))%>%na.omit()%>% select(Glu_P))
  
Mountain_data_cleaned[is.na(Mountain_data_cleaned)] <- mean_for_fill
rm(mean_for_fill)

# Replace discrete data NA by mode and continuous data NA by median

#bands3_reduced %>% 
 # mutate_if(is.numeric, function(current_density) ifelse(is.na(current_density), #median(current_density, na.rm = T), current_density))

#Discrete
bands3_reduced %>%
  mutate(proof_cut=replace_na(proof_cut,median(proof_cut, na.rm = TRUE)))
bands3_reduced %>%
  mutate(viscosity=replace_na(viscosity,median(viscosity, na.rm = TRUE)))
bands3_reduced %>%
  mutate(ink_temperature=replace_na(ink_temperature,median(ink_temperature, na.rm = TRUE)))
bands3_reduced %>%
  mutate(humidity=replace_na(humidity,median(humidity, na.rm = TRUE)))
bands3_reduced %>%
  mutate(blade_pressure=replace_na(blade_pressure,median(blade_pressure, na.rm = TRUE)))
bands3_reduced %>%
  mutate(press_speed=replace_na(press_speed,median(press_speed, na.rm = TRUE)))
bands3_reduced %>%
  mutate(roller_durometer=replace_na(roller_durometer,mean(roller_durometer, na.rm = TRUE)))
bands3_reduced %>%
  mutate(current_density=replace_na(current_density,median(current_density, na.rm = TRUE)))
bands3_reduced %>%
  mutate(anode_space_ratio=replace_na(anode_space_ratio,median(anode_space_ratio, na.rm = TRUE)))
bands3_reduced %>%
  mutate(chrome_content=replace_na(chrome_content,median(chrome_content, na.rm = TRUE)))

#Continous
bands3_reduced %>%
  mutate(caliper=replace_na(caliper,median(caliper, na.rm = TRUE)))
bands3_reduced %>%
  mutate(roughness=replace_na(roughness,median(roughness, na.rm = TRUE)))
bands3_reduced %>%
  mutate(varnish_pct=replace_na(varnish_pct,median(varnish_pct, na.rm = TRUE)))
bands3_reduced %>%
  mutate(ink_pct=replace_na(ink_pct,median(ink_pct, na.rm = TRUE)))
bands3_reduced %>%
  mutate(wax=replace_na(wax,median(wax, na.rm = TRUE)))
bands3_reduced %>%
  mutate(hardener=replace_na(hardener,median(chrome_content, na.rm = TRUE)))
bands3_reduced %>%
  mutate(solvent_pct=replace_na(solvent_pct,median(solvent_pct, na.rm = TRUE)))

```

## Boruta algo 

```{r}
#we treat the missing values 
bands3_reduced <- bands3_reduced[complete.cases(bands3_reduced),]

#convert categoric into factor
#quali <- c(29,1:11)
convert <- c(29, 1:11)
#bands3_reduced[,convert] <- data.frame(apply(bands3_reduced[convert], 2, #as.factor))  --> marche pas donc 1 par 1 

bands3_reduced$grain_screened <- as.factor(bands3_reduced$grain_screened)
bands3_reduced$proof_ink <- as.factor(bands3_reduced$proof_ink)
bands3_reduced$paper_type <- as.factor(bands3_reduced$paper_type)
bands3_reduced$ink_type <- as.factor(bands3_reduced$ink_type)
bands3_reduced$solvent_type <- as.factor(bands3_reduced$solvent_type)
bands3_reduced$cylinder_type <- as.factor(bands3_reduced$cylinder_type)
bands3_reduced$press_type <- as.factor(bands3_reduced$press_type)
bands3_reduced$press <- as.factor(bands3_reduced$press)
bands3_reduced$cylinder_size <- as.factor(bands3_reduced$cylinder_size)
bands3_reduced$location <- as.factor(bands3_reduced$location)
bands3_reduced$plating_tank <- as.factor(bands3_reduced$plating_tank)
bands3_reduced$band_type <- as.factor(bands3_reduced$band_type)


#library(Boruta)
#library(targets)
# Decide if a variable is important or not using Boruta
set.seed(123)
boruta_output <- Boruta(band_type ~ . , data=bands3_reduced, doTrace=2) # perform Boruta search

plot(boruta_output, xlab = "", xaxt = "n")
lz<-lapply(1:ncol(boruta_output$ImpHistory),function(i)
boruta_output$ImpHistory[is.finite(boruta_output$ImpHistory[,i]),i])
names(lz) <- colnames(boruta_output$ImpHistory)
Labels <- sort(sapply(lz,median))
axis(side = 1,las=2,labels = names(Labels),
at = 1:ncol(boruta_output$ImpHistory), cex.axis = 0.7)

```
## Random forest

```{r}

bands3_reduced.tr$grain_screened <- as.factor(bands3_reduced.tr$grain_screened)
bands3_reduced.tr$proof_ink <- as.factor(bands3_reduced.tr$proof_ink)
bands3_reduced.tr$paper_type <- as.factor(bands3_reduced.tr$paper_type)
bands3_reduced.tr$ink_type <- as.factor(bands3_reduced.tr$ink_type)
bands3_reduced.tr$solvent_type <- as.factor(bands3_reduced.tr$solvent_type)
bands3_reduced.tr$cylinder_type <- as.factor(bands3_reduced.tr$cylinder_type)
bands3_reduced.tr$press_type <- as.factor(bands3_reduced.tr$press_type)
bands3_reduced.tr$press <- as.factor(bands3_reduced.tr$press)
bands3_reduced.tr$cylinder_size <- as.factor(bands3_reduced.tr$cylinder_size)
bands3_reduced.tr$location <- as.factor(bands3_reduced.tr$location)
bands3_reduced.tr$plating_tank <- as.factor(bands3_reduced.tr$plating_tank)
bands3_reduced.tr$band_type <- as.factor(bands3_reduced.tr$band_type)

bands3_reduced.te$grain_screened <- as.factor(bands3_reduced.te$grain_screened)
bands3_reduced.te$proof_ink <- as.factor(bands3_reduced.te$proof_ink)
bands3_reduced.te$paper_type <- as.factor(bands3_reduced.te$paper_type)
bands3_reduced.te$ink_type <- as.factor(bands3_reduced.te$ink_type)
bands3_reduced.te$solvent_type <- as.factor(bands3_reduced.te$solvent_type)
bands3_reduced.te$cylinder_type <- as.factor(bands3_reduced.te$cylinder_type)
bands3_reduced.te$press_type <- as.factor(bands3_reduced.te$press_type)
bands3_reduced.te$press <- as.factor(bands3_reduced.te$press)
bands3_reduced.te$cylinder_size <- as.factor(bands3_reduced.te$cylinder_size)
bands3_reduced.te$location <- as.factor(bands3_reduced.te$location)
bands3_reduced.te$plating_tank <- as.factor(bands3_reduced.te$plating_tank)
bands3_reduced.te$band_type <- as.factor(bands3_reduced.te$band_type)

#band_type = as.factor(bands3_reduced$band_type)
#bands3_reduced$band_type.new = band_type

#band_type = as.factor(bands3_reduced.te$band_type)
#bands3_reduced.te$band_type.new = band_type


rf <- randomForest( band_type ~ .,data=bands3_reduced, importance = TRUE)
pred = predict(rf, newdata=bands3_reduced)
               

predtr <- predict(rf, newdata = bands3_reduced.tr)
predte <-  predict(rf, newdata=bands3_reduced.te)
cmtr <-   table(bands3_reduced.tr, predtr)      #impossible d’utiliser xtfrm sur un tableau de données (data frame)

cmte <-  table(bands3_reduced.te, predte) #impossible d’utiliser xtfrm sur un tableau de données (data frame)
> 
varImpPlot(rf, cex = 0.65)
importance(rf)
Acc_tr <- sum(diag(cmtr))/sum(cmtr)
Acc_te <- sum(diag(cmte))/sum(cmte)


cm
Acc
```

## CART model 

```{r}
library(rpart)
set.seed(123456)
bands <- rpart(band_type ~ ., method = "class", data = bands3_reduced.tr, control = rpart.control(minsplit = 4,
    cp = 1e-05), model = TRUE)
summary(bands)
```

```{r}
par(pty = "s", mar = c(1, 1, 1, 1))
plot(bands, cex = 1)
text(bands, cex = 0.6)
```



## Naïve Bayes

Conditional density Plots with 'usekernel=TRUE' 
```{r}
model.nb <- naive_bayes(band_type ~ .,
                       data = bands3_reduced.tr, usekernel=TRUE, laplace=1)
#par(mfrow=c(2,2))
plot(model.nb, arg.num = list(col = 1:3,
                             legend.position = "topright",
                             legend.cex = 0.8),
     prob="conditional")
par(mfrow=c(1,1))
model.nb
```


Conditional density plots with 'uskernel=FALSE'. It means that Gaussian distribution is applied to 'numeric' vairable. 
```{r}
model.nb2 <- naive_bayes(band_type ~ .,
                       data = bands3_reduced.tr, usekernel=FALSE, laplace=1) 
#par(mfrow=c(2,2))
plot(model.nb2, arg.num = list(col = 1:3,
                             legend.position = "topright",
                             legend.cex = 0.8), prob="conditional")
par(mfrow=c(1,1))
model.nb2
```

# Confusion matrix train data set 
```{r}
p1 <- predict(model.nb, bands3_reduced.tr[quanti])
(tab1 <- table(p1, bands3_reduced.tr$band_type))
sum(diag(tab1)) / sum(tab1)
```
The accuracy for the train data set is 75,2381 %.

# Confusion Matrix test data set 
```{r}
p2 <- predict(model.nb, bands3_reduced.te[quanti])
(tab2 <- table(p2, bands3_reduced.te$band_type))
sum(diag(tab2)) / sum(tab2)
```
The accuracy for the train data set is 66,19718 %.


## K-NN Model

We use a 2-NN to predict the test set using the training set
```{R}
library(caret)
set.seed(123)
KNN <- knn3(data=bands3_reduced.tr, band_type ~ ., k=2)
MR.te.pred <- predict(KNN, newdata = bands3_reduced.tr,type ="class") 
TAB <- table(Obs=bands3_reduced.tr$band_type, Pred= BR.te.pred) # confusion matrix 
TAB
(ACC <- sum(diag(TAB))/sum(TAB)) # accuracy 
```
The accuracy is aroud 86,666%.


## Neural Network 

```{r cache = TRUE, message = FALSE, warning = FALSE, results = 'hide'}
set.seed(1)
fitControl <- trainControl(method = "cv", 
                           number = 10)
nnetGrid <-  expand.grid(size = seq(from = 1, to = 6, by = 1),
                        decay = seq(from = 0.1, to = 0.5, by = 0.1))
nnetFit <- train(band_type ~ ., 
                 data = bands3_reduced.tr,
                 method = "nnet",
                 metric = "Accuracy",
                 tuneGrid = nnetGrid,
                 trControl = fitControl)
```

```{r}
plot(nnetFit)
```

The best Neural Networks parameters would be to choose 6 hidden layers, with a decay of 0.1. 

The manually written Neural Network model 
```{r}
set.seed(345)
nn4 <- nnet(band_type ~ ., data=bands3_reduced.tr, size=6, decay = 0.1)
nn4_pred <- predict(nn4, type="class")
tab4 <- table(Obs=bands3_reduced.tr$band_type, Pred=nn4_pred) # confusion matrix
tab4
(acc4 <- sum(diag(tab4))/sum(tab4)) # accuracy
```

Here it says that the accuracy is 82,86%.

```{r}
# Confusion Matrix
confusionMatrix(data=as.factor(nn4_pred), reference = bands3_reduced.tr$band_type)
```
